---
title: "Analysis and Figures"
author: "Samuel R.P-J. Ross"
date: '2022-07-08'
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Packages:
library(nlme)
library(patchwork)
library(here)
library(brms)
library(tidybayes)
library(cowplot)
library(ape)
library(dplyr)
library(ggplot2)
library(tibble)
library(tidyr)
library(readr)
library(purrr)
library(stringr)
library(forcats)
#library(simpleboot)
library(segmented)
library(mcp)
library(rjags)
library(EnvCpt)
library(lubridate)

# get data
load(here("Data/Stability_Acoustic_Indices.rda"))
load(here("Data/Stability_Species_Detections.rda"))

# get site names ordered by land use PC1 for later use in figures
load(here("Data/all_landuse.rda"))
Site_order<-Landuse_1000$site_id[order(Landuse_1000$PC1)]
rm(Landuse_1000)
```

This markdown is for building models to test effects of land use and typhoons on acoustic indices and bird species detections. Modeling framework uses Bayesian models to test for effects of typhoons and land use (plus their interaction) on means and variabilities of acoustic indices and bird detections. Also tests land use effect on acoustic index resistance and recovery. Can test for spatial autocorrelation of model residuals and fit spatial error terms where needed.

### Acoustic indices

## acoustic index mean states

**NDSI - negative change after typhoon**

```{r}
# get pre vs post data for comparison
dat_pre<-tidy.stability_AI %>%
  filter(Index %in% "NDSI" & response_variable %in% 'Pre_mean') 
dat_post<-tidy.stability_AI %>%
  filter(Index %in% "NDSI" & response_variable %in% 'Post_mean')
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
#names(df)[1] <- names(Landuse_1000)[1]
#df <- left_join(df, Landuse_1000, by = "site_id")

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse * Typhoon + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

summary(mod_nonspatial_beta)

```

plot results:

```{r}

mut_mod<-mod_nonspatial_beta %>%
  spread_draws(b_TyphoonPost, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + r_Site_ID) # get posterior distribution data for plotting

# determine whether credible intervals span zero, and store as binary (to show in plot): 
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
}
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor

# plot posterior typhoon effect
mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "Site") + 
  cowplot::theme_minimal_grid(font_size = 14,
                              colour = "grey92")

```

**NDSI_Bio - no effect of typhoon or land use**

```{r}
# get pre vs post data for comparison
dat_pre<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Bio" & response_variable %in% 'Pre_mean') 
dat_post<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Bio" & response_variable %in% 'Post_mean')
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
#names(df)[1] <- names(Landuse_1000)[1]
#df <- left_join(df, Landuse_1000, by = "site_id")

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse * Typhoon + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 

mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

summary(mod_nonspatial_beta)

```

plot results:

```{r}

mut_mod<-mod_nonspatial_beta %>%
  spread_draws(b_TyphoonPost, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + r_Site_ID) # get posterior distribution data for plotting

# determine whether credible intervals span zero, and store as binary (to show in plot): 
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
}
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor

# plot posterior typhoon effect
mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "Site") + 
  cowplot::theme_minimal_grid(font_size = 14,
                              colour = "grey92")

```

**NDSI_Anthro - positive change after typhoon**

```{r}
# get pre vs post data for comparison
dat_pre<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Anth" & response_variable %in% 'Pre_mean') 
dat_post<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Anth" & response_variable %in% 'Post_mean')
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
#names(df)[1] <- names(Landuse_1000)[1]
#df <- left_join(df, Landuse_1000, by = "site_id")

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse * Typhoon + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

```

Plot typhoon effect: 

```{r}
mut_mod<-mod_nonspatial_beta %>%
  spread_draws(b_TyphoonPost, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + r_Site_ID) # get posterior distribution data for plotting

# determine whether credible intervals span zero, and store as binary (to show in plot): 
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
}
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor

# plot posterior typhoon effect
mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "Site") + 
  cowplot::theme_minimal_grid(font_size = 14,
                              colour = "grey92")
```

## acoustic index temporal variability

**NDSI - no effect of typhoon or land use**

```{r}

# get pre vs post data for comparison
dat_pre<-tidy.stability_AI %>%
  filter(Index %in% "NDSI" & response_variable %in% 'Pre_Var') 
dat_post<-tidy.stability_AI %>%
  filter(Index %in% "NDSI" & response_variable %in% 'Post_Var')
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
#names(df)[1] <- names(Landuse_1000)[1]
#df <- left_join(df, Landuse_1000, by = "site_id")

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

# fit random intercept and slope model because random slope model didn't converge well.
mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse * Typhoon + (1+Landuse*Typhoon|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation
```

**NDSI_Bio - no effect of typhoon or land use**

```{r}
# get pre vs post data for comparison
dat_pre<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Bio" & response_variable %in% 'Pre_Var') 
dat_post<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Bio" & response_variable %in% 'Post_Var')
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
#names(df)[1] <- names(Landuse_1000)[1]
#df <- left_join(df, Landuse_1000, by = "site_id")

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

# fit random intercept and slope model because random slope model didn't converge well.
mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse * Typhoon + (1+Landuse*Typhoon|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation
```

**NDSI_Anthro - no effect of typhoon or land use**

```{r}
# get pre vs post data for comparison
dat_pre<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Anth" & response_variable %in% 'Pre_Var') 
dat_post<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Anth" & response_variable %in% 'Post_Var')
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
#names(df)[1] <- names(Landuse_1000)[1]
#df <- left_join(df, Landuse_1000, by = "site_id")

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

# fit random intercept and slope model because random slope model didn't converge well.
mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse * Typhoon + (1+Landuse*Typhoon|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 

mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

```

## acoustic index resistance

**NDSI - no effect of land use**

```{r}
# get pre vs post data for comparison
df<-tidy.stability_AI %>%
  filter(Index %in% "NDSI" & response_variable %in% 'Resist') 
df<-df[complete.cases(df),]

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

```

**NDSI_Bio - no effect of land use**

```{r}
# get pre vs post data for comparison
df<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Bio" & response_variable %in% 'Resist') 
df<-df[complete.cases(df),]

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

```

**NDSI_Anthro - no effect of land use**

```{r}
# get pre vs post data for comparison
df<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Anth" & response_variable %in% 'Resist') 
df<-df[complete.cases(df),]

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

```

## acoustic index recovery time

**NDSI - no effect of land use**

```{r}
# get pre vs post data for comparison
df<-tidy.stability_AI %>%
  filter(Index %in% "NDSI" & response_variable %in% 'Recov') 
df<-df[complete.cases(df),]

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation

```

**NDSI_Bio - no effect of land use**

```{r}
# get pre vs post data for comparison
df<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Bio" & response_variable %in% 'Recov') 
df<-df[complete.cases(df),]

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation
```

**NDSI_Anthro - no effect of land use**

```{r}
# get pre vs post data for comparison
df<-tidy.stability_AI %>%
  filter(Index %in% "NDSI_Anth" & response_variable %in% 'Recov') 
df<-df[complete.cases(df),]

# change levels for model
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
#df$site_id<-df$site_id %>% parse_character() %>% parse_factor(levels = c(df$site_id[order(df$PC1)]))

# fit random intercept and slope model because random slope model didn't converge well.
mod_nonspatial_beta <- 
  brm(data = df, family = Beta(),
      Stability ~ 1 + Landuse + (1+Landuse|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666)
mod_nonspatial_beta <- add_criterion(mod_nonspatial_beta, "loo")

#check MCMC traces
mcmc_plot(mod_nonspatial_beta, type = "trace") + theme_cowplot()
#check for agreement of chains
mcmc_plot(mod_nonspatial_beta, type = "dens_overlay") + theme_cowplot()
# plot posterior estimates of fixed effects
mcmc_plot(mod_nonspatial_beta, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()

## no effects ##
## Parameter fits and stats 
mod_nonspatial_beta$fit # Rhat values closer to 1 and n_eff values > 1000 are ideal.
bayes_R2(mod_nonspatial_beta) # pseudo r-squared of model
# simulate data from 500 random draws of posterior and compare it to observed data
# the black line should run through the center of the blue lines
pp_check(mod_nonspatial_beta, ndraws = 500) + theme_cowplot()

## Spatial Autocorrelation test
bres <- residuals(mod_nonspatial_beta)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T)) # make distance matrix 
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
Moran.I(bres, d_mat_inv) # non-significant = no spatial autocorrelation
```

## acoustic index spatial variability


Make Bayesian change-point model per species and habitat combination. For each one, compare zero change points (no typhoon effect), 2 breaks (approx. typhoon effects, weak priors), and 3rd change point (following acoustic index results).

*NDSI*

```{r}
df =tidy.spatial_AI %>% filter(Index == "NDSI" & response_group == "Total_var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelA<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI Spatial variability (all sites)") + theme_cowplot()

```

Test for land use effects: 

```{r}

## Forest sites ##
df =tidy.spatial_AI %>% filter(Index == "NDSI" & response_group == "Forest_Var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelB<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI Spatial variability (Forest sites)") + theme_cowplot()

## Developed sites ##
df =tidy.spatial_AI %>% filter(Index == "NDSI" & response_group == "Developed_Var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelC<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI Spatial variability (Developed sites)") + theme_cowplot()

```

Plot results:

```{r}
df =tidy.spatial_AI %>% filter(Index == "NDSI" & response_group == "Total_var")

panel_a<-df %>% ggplot(aes(x = Date_Time,
                  y = Stability)) +
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F) + 
  labs(x = "Time",
       y = "NDSI spatial variability") + 
  theme_cowplot(12) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) 

df<-tidy.spatial_AI %>% filter(Index %in% "NDSI" & response_group %in% c('Forest_Var','Developed_Var')) 
df$response_group<-df$response_group %>% as.character() %>% parse_factor(levels = c('Forest_Var','Developed_Var'))

panel_b<-df %>% ggplot(aes(x = Date_Time,
                  y = Stability,
                  col = response_group)) +
  scale_colour_manual(values = c("#29a62b","#a629a4")) +
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F) + 
  labs(x = "Time",
       y = "NDSI spatial variability") + 
  theme_cowplot(12) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) 
```

```{r}
panel_a / panel_b
```

*NDSI_Bio*

```{r}
df =tidy.spatial_AI %>% filter(Index == "NDSI_Bio" & response_group == "Total_var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelD<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI_Bio Spatial variability (All sites)") + theme_cowplot()

```

Test for land use effects: 

```{r}

## Forest sites ##
df =tidy.spatial_AI %>% filter(Index == "NDSI_Bio" & response_group == "Forest_Var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 2 change points
PanelE<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI_Bio Spatial variability (Forest sites)") + theme_cowplot()


## Developed sites ##
df =tidy.spatial_AI %>% filter(Index == "NDSI_Bio" & response_group == "Developed_Var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelF<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI_Bio Spatial variability (Developed sites)") + theme_cowplot()

```

Plot results:

```{r}
df =tidy.spatial_AI %>% filter(Index == "NDSI_Bio" & response_group == "Total_var")

panel_a<-df %>% ggplot(aes(x = Date_Time,
                  y = Stability)) +
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F) + 
  labs(x = "Time",
       y = "Biophony spatial variability") + 
  theme_cowplot(12) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) 

df<-tidy.spatial_AI %>% filter(Index %in% "NDSI_Bio" & response_group %in% c('Forest_Var','Developed_Var')) 
df$response_group<-df$response_group %>% as.character() %>% parse_factor(levels = c('Forest_Var','Developed_Var'))

panel_b<-df %>% ggplot(aes(x = Date_Time,
                  y = Stability,
                  col = response_group)) +
  scale_colour_manual(values = c("#29a62b","#a629a4")) +
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F) + 
  labs(x = "Time",
       y = "Biophony spatial variability") + 
  theme_cowplot(12) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) 
```

```{r}
panel_a / panel_b
```

*NDSI_Anthro*

```{r}
df =tidy.spatial_AI %>% filter(Index == "NDSI_Anth" & response_group == "Total_var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelG<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI_Anthro Spatial variability (All sites)") + theme_cowplot()

```

Test for land use effects: 

```{r}
## Forest sites ##
df =tidy.spatial_AI %>% filter(Index == "NDSI_Anth" & response_group == "Forest_Var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelH<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI_Anthro Spatial variability (Forest sites)") + theme_cowplot()


## Developed sites ##
df =tidy.spatial_AI %>% filter(Index == "NDSI_Anth" & response_group == "Developed_Var")
df2 = df %>%
  slice(which(row_number() %% 12 == 1)) %>% # subset to every 6 hours (good tradeoff between MCMC speed and data resolution)
  #mutate(Date_Time = yday(Date_Time)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# get predicted breakpoint locations
psis = c(271, 278)

# create time series
tsData <- ts(
  c(df2$Stability),
  frequency = 28
)
#detrend weekly cycles
detrended <- stl(tsData, s.window = 28)
plot(detrended)
# new data frame with detrended data
trend = data.frame(Stability = as.numeric(detrended$time.series[,"trend"]), Date_Time = df2$Date_Time + 242.5000)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)

# Model with one changepoint
model1 = list(Stability ~ 1, 1~ 1)  # one intercept-only segments
fit_mcp1 = mcp(model1, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 280))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

# Model with two changepoint
model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 275, cp_2 = 290))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))


# model with 3 breakpoints
model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
prior = list(
  cp_1 = "dunif(260,277)", # uniform priors truncated at specified points
  cp_2 = "dunif(270,285)",  
  cp_3 = "dunif(285,300)" 
)
fit_mcp3 = mcp(model3, data = trend, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

# model comparison
fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo)

# fit_mcp3 is best - 3 change points
PanelI<-plot(fit_mcp3) + geom_vline(xintercept = psis) + xlab("Time") + ylab("NDSI_Anthro Spatial variability (Developed sites)") + theme_cowplot()

```

Plot results:

```{r}
df =tidy.spatial_AI %>% filter(Index == "NDSI_Anth" & response_group == "Total_var")

panel_a<-df %>% ggplot(aes(x = Date_Time,
                  y = Stability)) +
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F) + 
  labs(x = "Time",
       y = "Anthropophony spatial variability") + 
  theme_cowplot(12) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) 

df<-tidy.spatial_AI %>% filter(Index %in% "NDSI_Anth" & response_group %in% c('Forest_Var','Developed_Var')) 
df$response_group<-df$response_group %>% as.character() %>% parse_factor(levels = c('Forest_Var','Developed_Var'))

panel_b<-df %>% ggplot(aes(x = Date_Time,
                  y = Stability,
                  col = response_group)) +
  scale_colour_manual(values = c("#29a62b","#a629a4")) +
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date_Time[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F) + 
  labs(x = "Time",
       y = "Anthropophony spatial variability") + 
  theme_cowplot(12) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) 
```

```{r}
panel_a / panel_b
```

Plot change-point multi-panel figure: 

```{r}

(PanelA + PanelB + PanelC) / (PanelD + PanelE + PanelF) / (PanelG + PanelH + PanelI)

```

### Bird detections

NB: Bird detections were not made at every site, so the random site effect fills in the missing sites when constructing posterior draws etc. (we simply ignore those results from sites where detections were not observed).

## bird detection mean states

**Total detections - species x typhoon effect**

```{r}
dat_pre<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.5 & response_variable %in% 'Pre_mean') 
dat_post<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.5 & response_variable %in% 'Post_mean') 
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)

# change levels for model
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))

df$Stability<-df$Stability+1 # try this to run lognormal model (cannot have zero values)

# set weakly informative priors
all_priors<-c(
  set_prior("normal(0, 2)",coef = "LanduseDeveloped"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost"),
  set_prior("normal(0, 2)",coef = "Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "TyphoonPost"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost:Species_IDOtus_elegans"))

# Fit bayesian mixed effects model
mod_nonspatial_log <- 
  brm(data = df, family = lognormal(),
      Stability ~ 1 + Landuse * Typhoon * Species_ID + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666, prior = all_priors)

brms::mcmc_plot(mod_nonspatial_log, type = "trace") + theme_cowplot()
#check for agreement of chains
brms::mcmc_plot(mod_nonspatial_log, type = "dens_overlay") + theme_cowplot()
# plot posterior probabilities
brms::mcmc_plot(mod_nonspatial_log, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()
pp_check(mod_nonspatial_log, ndraws = 500) + theme_cowplot() +  scale_x_continuous(limits = c(0,50)) # good fit to data

bayes_R2(mod_nonspatial_log)

bres <- residuals(mod_nonspatial_log)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T))
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
ape::Moran.I(bres, d_mat_inv)

summary(mod_nonspatial_log)
```

Plot main species effect:

```{r}
# Horornis #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_Species_IDHorornis_diphone, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_Species_IDHorornis_diphone + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp) 
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
horornisplot <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","navajowhite")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (species effect)",
       y = "") + 
  cowplot::theme_minimal_grid()

# Otus #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_Species_IDOtus_elegans, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_Species_IDOtus_elegans + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
otusplot <-mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","navajowhite")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (species effect)",
       y = "") + 
  cowplot::theme_minimal_grid()

# plots #
plot_grid(horornisplot, otusplot, 
          ncol = 2, align = "hv", 
          labels = c("Horonis", "Otus"))
```

Plot typhoon x species interaction:

```{r}
# Corvus #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_TyphoonPost, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
corvusplot <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "Site") + 
  cowplot::theme_minimal_grid()

# Horornis #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_TyphoonPost, `b_TyphoonPost:Species_IDHorornis_diphone`, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + `b_TyphoonPost:Species_IDHorornis_diphone` + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp) 
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
horornisplot <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "") + 
  cowplot::theme_minimal_grid()

# Otus #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_TyphoonPost, `b_TyphoonPost:Species_IDOtus_elegans`, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + `b_TyphoonPost:Species_IDOtus_elegans` + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
otusplot <-mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "") + 
  cowplot::theme_minimal_grid()

# plots #
plot_grid(corvusplot, horornisplot, otusplot, 
          ncol = 3, align = "hv", 
          labels = c("Corvus", "Horonis", "Otus"))
```

## bird detection temporal variability

**Total detections - typhoon effect**

```{r}
dat_pre<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.5 & response_variable %in% 'Pre_Var') 
dat_post<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.5 & response_variable %in% 'Post_Var') 
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)

# change levels for model
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))

df$Stability<-df$Stability+1 # try this to run lognormal model (cannot have zero values)

# set weakly informative priors
all_priors<-c(
  set_prior("normal(0, 2)",coef = "LanduseDeveloped"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost"),
  set_prior("normal(0, 2)",coef = "Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "TyphoonPost"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost:Species_IDOtus_elegans"))

# Fit bayesian mixed effects model
mod_nonspatial_log <- 
  brm(data = df, family = lognormal(),
      Stability ~ 1 + Landuse * Typhoon * Species_ID + (1|Site_ID),
      iter = 5e4, warmup = 5000, chains = 4, cores = 4, thin = 2,
      seed = 666, prior = all_priors)

brms::mcmc_plot(mod_nonspatial_log, type = "trace") + theme_cowplot()
#check for agreement of chains
brms::mcmc_plot(mod_nonspatial_log, type = "dens_overlay") + theme_cowplot()
# plot posterior probabilities
brms::mcmc_plot(mod_nonspatial_log, type = "intervals",prob = 0.68, prob_outer = 0.95, variable = "^b_", regex = TRUE) + theme_cowplot()
pp_check(mod_nonspatial_log, ndraws = 500) + theme_cowplot() +  scale_x_continuous(limits = c(0,50)) # good fit to data

bayes_R2(mod_nonspatial_log)

bres <- residuals(mod_nonspatial_log)[,"Estimate"]
d_mat = as.matrix(dist(df[,c("Lat", "Long")], diag=T, upper=T))
d_mat_inv <- 1/d_mat
d_mat_inv[which(d_mat_inv == Inf)] <- 0
ape::Moran.I(bres, d_mat_inv)

summary(mod_nonspatial_log)
```

Plot typhoon effect:

```{r}
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_TyphoonPost, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp) 
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "") + 
  cowplot::theme_minimal_grid()
```

Plot by species (for supplement):

```{r}
# Corvus #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_TyphoonPost, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
corvusplot <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "Site") + 
  cowplot::theme_minimal_grid()

# Horornis #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_TyphoonPost, `b_TyphoonPost:Species_IDHorornis_diphone`, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + `b_TyphoonPost:Species_IDHorornis_diphone` + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp) 
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
horornisplot <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "") + 
  cowplot::theme_minimal_grid()

# Otus #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_TyphoonPost, `b_TyphoonPost:Species_IDOtus_elegans`, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_TyphoonPost + `b_TyphoonPost:Species_IDOtus_elegans` + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp)
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
otusplot <-mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","skyblue")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (typhoon effect)",
       y = "") + 
  cowplot::theme_minimal_grid()

# plots #
plot_grid(corvusplot, horornisplot, otusplot, 
          ncol = 3, align = "hv", 
          labels = c("Corvus", "Horonis", "Otus"))
```


## bird detection spatial variability

Make Bayesian change-point model per species and habitat combination. For each one, compare zero change points (no typhoon effect), 2 breaks (approx. typhoon effects, weak priors), and 3rd change point (following acoustic index results).

Total spatial variability:

```{r}
### Corvus macrorhynchos - No change points
df =tidy.spatial_bird %>% filter(Species == "Corvus_macrorhynchos" & response_group == "Total_Var")

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp0 best - no change points

PanelA<-plot(fit_mcp0) + geom_vline(xintercept = psis) + xlab("Time") + ylab("C. macrorhynchos detection spatial variability (All sites)") + theme_cowplot()


### Horornis diphone - One change point
df =tidy.spatial_bird %>% filter(Species == "Horornis_diphone" & response_group == "Total_Var")

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp1 best - one change point

PanelD<-plot(fit_mcp1) + geom_vline(xintercept = psis) + xlab("Time") + ylab("H. diphone detection spatial variability (All sites)") + theme_cowplot()


### Otus elegans - One change point
df =tidy.spatial_bird %>% filter(Species == "Otus_elegans" & response_group == "Total_Var")

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp0 best - no change point

PanelG<-plot(fit_mcp0) + geom_vline(xintercept = psis) + xlab("Time") + ylab("O. elegans detection spatial variability (All sites)") + theme_cowplot()

```

Plot results:

```{r}
df<-tidy.spatial_bird %>% filter(response_group == "Total_Var")
Sp_labs<-c('C. macrorhynchos','H. diphone','O. elegans')
names(Sp_labs)<-c('Corvus_macrorhynchos','Horornis_diphone','Otus_elegans')

panel_a<-df %>% ggplot(aes(x = Date,
                  y = Stability,
                  col = Species)) +
#  scale_alpha_manual(values = c(1,0.6,0.3)) +
  scale_linetype_manual(values = c(1,2,4)) +
  scale_colour_manual(values = c("gray80","skyblue","navajowhite")) +
  geom_vline(xintercept = df$Date[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F, alpha = 0.8) + 
  labs(x = "Time",
       y = "Species detection spatial variability") + 
  theme_cowplot(12) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) 
```

Now check for landuse effect.

Forest spatial variability:

```{r}
### Corvus macrorhynchos - 1 change point
df =tidy.spatial_bird %>% filter(Species == "Corvus_macrorhynchos" & response_group == "Forest_Var")

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp1 most parsimonious - 1 change point

PanelB<-plot(fit_mcp1) + geom_vline(xintercept = psis) + xlab("Time") + ylab("C. macrorhynchos detection spatial variability (Forest sites)") + theme_cowplot()


### Horornis diphone - One change point
df =tidy.spatial_bird %>% filter(Species == "Horornis_diphone" & response_group == "Forest_Var")
df<-df[complete.cases(df),]

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp1 best - one change point

PanelE<-plot(fit_mcp1) + geom_vline(xintercept = psis) + xlab("Time") + ylab("H. diphone detection spatial variability (Forest sites)") + theme_cowplot()


### Otus elegans - No change
df =tidy.spatial_bird %>% filter(Species == "Otus_elegans" & response_group == "Forest_Var")

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp0 best - no change point

PanelH<-plot(fit_mcp0) + geom_vline(xintercept = psis) + xlab("Time") + ylab("O. elegans detection spatial variability (Forest sites)") + theme_cowplot()

```

Developed sites spatial variability:

```{r}
### Corvus macrorhynchos - 1 change point
df =tidy.spatial_bird %>% filter(Species == "Corvus_macrorhynchos" & response_group == "Developed_Var")

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp1 most parsimonious - 1 change point

PanelC<-plot(fit_mcp1) + geom_vline(xintercept = psis) + xlab("Time") + ylab("C. macrorhynchos detection spatial variability (Developed sites)") + theme_cowplot()


### Horornis diphone - One change point
df =tidy.spatial_bird %>% filter(Species == "Horornis_diphone" & response_group == "Developed_Var")
df<-df[complete.cases(df),]

df2 = df %>%
  mutate(Date_Time = yday(Date)) %>%
  group_by(Date_Time) %>%
  summarize(Stability = mean(Stability))

df2$Date_Time<-df2$Date_Time %>% as.Date() %>%  julian(origin = as.POSIXct("2018-01-01")) %>% as.numeric() # convert to numeric date format for model
df2$Date_Time<-df2$Date_Time - min(df2$Date_Time) # scale date to start at zero for model

# set approx. break points at typhoon levels
psis = c(30, 37)

# Intercept-only model (no cp)
model0 = list(Stability ~ 1)
fit_mcp0 = mcp(model0, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000)
#plot(fit_mcp0)

model1 = list(Stability ~ 1, 1~ 1)  # two intercept-only segments
fit_mcp1 = mcp(model1, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 35))  
#plot(fit_mcp1) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp1, pars = c("cp_1", "cp_2"))

model2 = list(Stability ~ 1, 1~ 1, 1~1)  # two intercept-only segments
fit_mcp2 = mcp(model2, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               inits = list(cp_1 = 30, cp_2 = 37))  
#plot(fit_mcp2) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp2, pars = c("cp_1", "cp_2"))

prior = list(
  cp_1 = "dnorm(30,5)", 
  cp_2 = "dnorm(35,5)",  
  cp_3 = "dnorm(42,5)" 
)

model3 = list(Stability ~ 1, 1~ 1, 1~1, 1~1)  # three intercept-only segments
fit_mcp3 = mcp(model3, data = df2, par_x = "Date_Time", 
               chains=8, cores = 8, adapt = 10000, 
               prior = prior)
#plot(fit_mcp3) + geom_vline(xintercept = psis)
#plot_pars(fit_mcp3, pars = c("cp_1", "cp_2", "cp_3"))

fit_mcp0$loo = loo(fit_mcp0)
fit_mcp1$loo = loo(fit_mcp1)
fit_mcp2$loo = loo(fit_mcp2)
fit_mcp3$loo = loo(fit_mcp3)
loo::loo_compare(fit_mcp0$loo, fit_mcp1$loo, fit_mcp2$loo, fit_mcp3$loo) 
# mcp1 best - one change point

PanelF<-plot(fit_mcp1) + geom_vline(xintercept = psis) + xlab("Time") + ylab("H. diphone detection spatial variability (Developed sites)") + theme_cowplot()

```


Plot results:

```{r}
df<-tidy.spatial_bird %>% filter(response_group == c("Forest_Var","Developed_Var"))
Sp_labs<-c('C. macrorhynchos','H. diphone','O. elegans')
names(Sp_labs)<-c('Corvus_macrorhynchos','Horornis_diphone','Otus_elegans')
df$response_group<-df$response_group %>% as.character() %>% parse_factor(levels = c('Forest_Var','Developed_Var'))

panel_b<-df %>% ggplot(aes(x = Date,
                  y = Stability,
#                  alpha = Species,
                  col = response_group)) +
  scale_colour_manual(values = c("#29a62b","#a629a4")) +
#  scale_alpha_manual(values = c(1,0.6,0.3)) +
  geom_vline(xintercept = df$Date[df$Period %in% 'Trami'][1],lty = 2) + 
  geom_vline(xintercept = df$Date[df$Period %in% 'Post-typhoon'][1],lty = 2) + 
  geom_line(show.legend = F, alpha = 0.8) + 
  labs(x = "Time",
       y = "Species detection spatial variability") + 
  theme_cowplot(12) + 
  theme(strip.background = element_rect(fill = 'white')) + 
  ylim(c(df$Stability %>% min(),
         df$Stability %>% max())) + 
  facet_grid(Species ~ .,
             labeller = labeller(Species = Sp_labs))

```

```{r}
panel_a/panel_b
```

Changepoint model multi-panel figure: 

```{r}

(PanelA + PanelB + PanelC) / (PanelD + PanelE + PanelF) / (PanelG + PanelH + plot_spacer())

```

### Legacy Figure S2

Finally, compare different automatic filtering thresholds for species detection confidence. Test the mean species effect on Horonis_diphone under three confidence thresholds. NB: to speed this up, we'll run 10x fewer iterations in the models. 

**Threshold = 0.5 **

```{r}
dat_pre<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.5 & response_variable %in% 'Pre_mean') 
dat_post<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.5 & response_variable %in% 'Post_mean') 
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
# change levels for model
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Stability<-df$Stability+1 # try this to run lognormal model (cannot have zero values)

# set weakly informative priors
all_priors<-c(
  set_prior("normal(0, 2)",coef = "LanduseDeveloped"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost"),
  set_prior("normal(0, 2)",coef = "Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "TyphoonPost"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDOtus_elegans"))

# Fit bayesian mixed effects model
mod_nonspatial_log <- 
  brm(data = df, family = lognormal(),
      round(Stability) ~ 1 + Landuse + Typhoon + Species_ID + # used round() as poisson needs integers
        Landuse:Typhoon + Landuse:Species_ID + Typhoon:Species_ID + (1|Site_ID),
      iter = 5e3, warmup = 500, chains = 4, cores = 4, thin = 2,
      seed = 666, prior = all_priors)

summary(mod_nonspatial_log)

#Plot - Horornis #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_Species_IDHorornis_diphone, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_Species_IDHorornis_diphone + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp) 
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
Plot_50 <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","navajowhite")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (species effect)",
       y = "") + 
  cowplot::theme_minimal_grid()
```

**Threshold = 0.75 **

```{r}
dat_pre<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.75 & response_variable %in% 'Pre_mean') 
dat_post<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.75 & response_variable %in% 'Post_mean') 
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
# change levels for model
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Stability<-df$Stability+1 # try this to run lognormal model (cannot have zero values)

# set weakly informative priors
all_priors<-c(
  set_prior("normal(0, 2)",coef = "LanduseDeveloped"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost"),
  set_prior("normal(0, 2)",coef = "Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "TyphoonPost"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDOtus_elegans"))

# Fit bayesian mixed effects model
mod_nonspatial_log <- 
  brm(data = df, family = lognormal(),
      round(Stability) ~ 1 + Landuse + Typhoon + Species_ID + # used round() as poisson needs integers
        Landuse:Typhoon + Landuse:Species_ID + Typhoon:Species_ID + (1|Site_ID),
      iter = 5e3, warmup = 500, chains = 4, cores = 4, thin = 2,
      seed = 666, prior = all_priors)

summary(mod_nonspatial_log)

#Plot - Horornis #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_Species_IDHorornis_diphone, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_Species_IDHorornis_diphone + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp) 
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
Plot_75 <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","navajowhite")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (species effect)",
       y = "") + 
  cowplot::theme_minimal_grid()
```

**Threshold = 0.9**

```{r}
dat_pre<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.9 & response_variable %in% 'Pre_mean') 
dat_post<-tidy.stability_bird %>%
  filter(Cutoff %in% 0.9 & response_variable %in% 'Post_mean') 
dat_pre<-dat_pre[complete.cases(dat_pre),]
dat_post<-dat_post[complete.cases(dat_post),]
dat_pre$Typhoon = rep("Pre", nrow(dat_pre))
dat_post$Typhoon = rep("Post", nrow(dat_post))
df <- rbind(dat_pre, dat_post)
# change levels for model
df$Typhoon<-df$Typhoon %>% parse_character() %>% parse_factor(levels = c('Pre','Post'))
df$Landuse<-df$Landuse %>% parse_character() %>% parse_factor(levels = c('Forest','Developed'))
df$Stability<-df$Stability+1 # try this to run lognormal model (cannot have zero values)

# set weakly informative priors
all_priors<-c(
  set_prior("normal(0, 2)",coef = "LanduseDeveloped"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "LanduseDeveloped:TyphoonPost"),
  set_prior("normal(0, 2)",coef = "Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "Species_IDOtus_elegans"),
  set_prior("normal(0, 2)",coef = "TyphoonPost"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDHorornis_diphone"),
  set_prior("normal(0, 2)",coef = "TyphoonPost:Species_IDOtus_elegans"))

# Fit bayesian mixed effects model
mod_nonspatial_log <- 
  brm(data = df, family = lognormal(),
      round(Stability) ~ 1 + Landuse + Typhoon + Species_ID + # used round() as poisson needs integers
        Landuse:Typhoon + Landuse:Species_ID + Typhoon:Species_ID + (1|Site_ID),
      iter = 5e3, warmup = 500, chains = 4, cores = 4, thin = 2,
      seed = 666, prior = all_priors)

summary(mod_nonspatial_log)

#Plot - Horornis #
mut_mod<-mod_nonspatial_log %>%
  spread_draws(b_Species_IDHorornis_diphone, r_Site_ID[Site_ID,]) %>%
  mutate(site_mean = b_Species_IDHorornis_diphone + r_Site_ID) # get posterior distribution data for plotting
mut_mod$sig<-0
for (i in 1:length(unique(mut_mod$Site_ID))) {
  temp<-mut_mod$site_mean[mut_mod$Site_ID %in% mut_mod$Site_ID[i]] %>% 
    quantile(c(0.05,0.95)) %>% # get 95% credible intervals
    sign() %>% # get sign of those intervals
    duplicated() # are the signs identical (no = zero-spanning)
  if(temp[2] %in% TRUE){ # if signs are identical (non-zero-spanning)
    mut_mod$sig[mut_mod$Site_ID %in% mut_mod$Site_ID[i]]<-1 # add significance indicator
  }
} # determine whether credible intervals span zero, and store as binary (to show in plot): 
rm(temp) 
mut_mod$sig<-mut_mod$sig %>% as.character() %>% parse_factor(levels = c('0','1')) # convert to factor
Plot_90 <- mut_mod %>%
  ggplot(aes(y = Site_ID %>% as.character %>% parse_factor(levels = Site_order), 
             x = site_mean, 
             fill = stat(x) > 0,
             shape = sig)) + 
  stat_halfeye(show.legend = F,slab_type = "pdf") +
  geom_vline(xintercept = 0, 
             linetype = "dashed") +
  scale_fill_manual(values = c("gray80","navajowhite")) +
  scale_shape_manual(values = c(21,8)) +
  labs(x = "Posterior draws (species effect)",
       y = "") + 
  cowplot::theme_minimal_grid()
```

Compare plots:

```{r}
# plots #
plot_grid(Plot_50, Plot_75, Plot_90, 
          ncol = 3, align = "hv", 
          labels = c("Threshold: 0.5", "Threshold: 0.75", "Threshold: 0.9"))
```